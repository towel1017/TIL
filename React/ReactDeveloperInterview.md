# 리액트 개발자 면접 질문

## 1. `CSR`와 `SSR`의 차이점은?

`CSR` (Client Side Rendering) :

- 처음 웹서버에 요청할 때 `데이터가 없는 문서를 반환`하고, <br>
  HTML 및 Static 파일들이 로드 되면서, <br>
  데이터가 있다면 데이터 또한 서버에 요청하고,
  데이터와 함께 화면상에 나타나게 된다. <br>
  그 후 사용자의 요청에 따라 javascript를 통해 <br>
  **`동적으로 서버에서 요청을 받아와서`** Rendering. <br>

`SSR` (Server Side Rendering) :

- `완전하게 만들어진` HTML 파일을 받아오고 Rendering 한다.
  웹 서버에 요청할 때 마다 `Browser 새로고침`이 일어나고,
  서버에 `새로운 페이지에 대한 요청`을 하는 방식.

---

### 2. 평소에 가장 자신있는 언어와 그 이유는? `장단점`에 대해서도 말해주세요.

- **`React`**, 자바스크립트 하이브리드 웹을 만들어 주는 library.
- 데이터가 업데이트 될 때 마다 `Data`를 `Virtual DOM` 에 `리렌더링`을 합니다.

**`장점`**

> - `Components` -> 모든 것을 컴포넌트 로 생각하며 사용하고, 커스터마이징한다. <br>
> - `JSX` -> Javascript의 Syntax 확장으로, 빠르고, Type-safe로 편리하게 사용할 수 있다.<br>
> - `단일방향 & Flux` -> 데이터가 항상 단일방향으로 흐르기 때문에, 추적이 쉽고, 디버깅이 쉽다.<br>
> - `라이브러리이므로`, 프레임워크와 함께 혼용가능.<br>
> - `CSR, SSR 을 지원`하여, SEO 호환 및 최적화 가능.<br>
> - 컴포넌트 `재사용성` 극대화<br>

**`단점`**

> - `VIEW ONLY`, View 이외의 기능은 써드파티 라이브러리(패키지, 모듈)를 이용하거나 직접 구현해야함.
> - IE8 이하는 지원하지 않음. ( 사실 의미가 없음 )

---

### 3. `효율적인 코드`를 작성하실 때 신경쓰는 부분이 어떤 것들이 있나요? <br><br>

1.  `코드의 재사용성`

> - 같은 코드,
>   같은 기능을 하는 함수들이 많아지는 경우
>   현저히 효율성은 떨어지기 때문에,<br>
>   최대한 같은 기능, 같은 역할을 하는 코드는 작성하지 않으려고 한다. <br>

2.  `UI 재사용성`

> - 같은 UI 및 컴포넌트가 겹치지 않게 하도록 합니다.
>   같은 템플릿이나 코드 및 UI 재사용성이 높은 리액트 에서는
>   그 장점을 극대화 시키도록 해야한다고 생각합니다.

---

### 4. `서버와 데이터 통신`을 해본 경험이 있나요?

- 네, `REST API` 와 `HTTP API`, `GraphQL` 로 서버와 데이터 통신을 한 경험이 있습니다.
- REST API는 ~
- HTTP API는 ~
- GraphQL은 ~

---

### 5. 리액트는 생명주기가 있고 그것을 맞춰주는 것이 어려운데, 이러한 부분은 어떻게 해셜하셨나요?

> - 리액트의 생명주기는 `Class Component`에서 존재하는데<br>
>   클래스 컴포넌트는 `componentDidMount 등의 여러 생명주기 메서드`들을 사용할 수 있지만,<br> `Functional Component` 에서는 `라이프사이클`이 존재하지 않으므로,<br>
>   온전히 render만 구현합니다.

> - `Class Component` 는 생명주기의 큰 문제가 존재합니다. <br>
>   바로 `props를 재사용` 하기 때문인데, <br>
>   그로 인해 `timeout` 등의 `lifecycle에 영향`을 주는
>   함수들을( this.props를 읽는 콜백을 가진 함수들 ) <br>
>   실행하는 동안 `props가 바뀔경우` 바뀌기 전에 로직이 실행되더라도,<br> > `바뀐 값이 영향`을 주므로 그에 대한 예방을 해야함.

> - `예방법`? 예방법은 props를 읽는 콜백을 가진 로직이 <br> `lifrcycle에 영향`을 줄 경우 <br> `this.props를 참조를 먼저 하는` 방법이 있다.

---

### 6. `라이브러리를` 선택할 때, 특정 `라이브러리`를 선택하게 된 이유가 있나요?

> - `React`를 선택을 했는데, <br>
>   리액트를 사용하는 이유는 현재 개발을 편리하게 해주는 `모듈이나 패키지`들이 많이 존재하고, <br>
>   컴포넌트 단위로 `커스터마이징` 할 수 있다는 점이 편리했고, <br> `HTML이 편리했던 저로써는 JSX`를 사용하는 것이 적응이 쉬웠습니다.

---

### 7. Closure를 currying과 함께 사용한 예시 코드를 작성해주세요.

> - `closure`란 `독립적인 함수`를 가리키며, <br> 클로저 안에 정의된 함수는 그 환경을 기억한다. <br> `한 함수 내에서 함수를 정의`하고 사용하면 `클로저`라고 한다.

---

### 8. 원시값과 참조값(array, object)의 차이점을 `메모리 관점`에서 설명해주세요.

> - `원시값은 단순한 데이터`로, bool, undefined, null 등의 단순한 값으로, 이런 `변수들을 값으로` 접근한다.

> - 참조값은 `메모리에 저장되는 객체`로 JS는 `메모리에 직접 접근하는 것을 허용하지 않으므로`, 참조를 해서 접근하는 것이다. 그래서 수정하는 것도 값을 수정하는 것이 아니라, `참조를 접근`하여 수정하는 것이다.

---

### 9. `서버에서 1초 단위`로 바뀌는 많은 양의 `동적 데이터`를 받아올 때, 실시간으로 바뀌는 데이터를 프론트단에서 어떻게 시각적으로 업데이트 할까요?

```

```

---

## **`Javascript`**

---

### 1. `Event Bubbling`에 대해서 설명해주세요.

> - JS 의 `DOM의 부모/자식 이벤트를 읽어오는 형식`의 특징으로 생기는 형식으로, <br> `부모에서 자식으로` 이벤트를 읽어오는 과정에서 `부모에게 이벤트가 전달되어 이벤트가 생기는 현상`이다.

---

### 2. 아래의 코드는 어떠한 차이가 있나요?

```js
    const add = function() { ... }
    const add = () => { ... }
```

> - `Arrow Function`은 항상 익명함수로, <br> `this, super` 등의 바인딩 또는 `new.target`을 바인딩 하지 않고, 그러므로 생성자로써 사용할 수 없다

> - `Function은` **`This`** 라는 개념이 생기면서, `Bind와 new 생성자`를 사용할 수 있다.

---

### 3. `strict mode` 를 사용했을 때의 구체적인 특징은?

---

## **`React`**

### 1. `useCallback/useMemo`에 대해서 설명해주세요.

> - `useCallback`은 특정 `함수를 재사용`하고 싶을때 사용합니다. <br> 사용방법은 `첫번째 인자`로 `재사용할 함수`를 받습니다. `두 번째 인자`로 `의존성 배열`을 받는데 그 배열내에 있는 값이 `바뀔 때 마다 다시 새로 렌더링하는 방식`으로 동작합니다.

> - `useMemo`는 특정 `연산된 값을 재사용`할 때 사용합니다. 사용방법은 `첫번째 인자`로 `재사용할 함수를 정의`해주면 되고, `두 번째 인자`로는 `의존성 배열`을 받는데 그 배열 내에 있는 `값이 바뀌지 않으면`, 새로 연산을 하지 않고, 전에 `연산되어있던 값을 재사용`합니다.

---

### 2. `리액트`에서 setState는 `비동기 동작`인가요, `동기동작`인가요?

- 리액트에서 setState는 `비동기 동작`입니다. 그렇기 때문에 `콜백 함수로 콘솔을 찍었을 때` 새로운 값이 아닌 `기존 값이 나오게 동작`합니다.

---

### 3. `setState`가 `비동기 동작`을 취했을 때 `얻을 수 있는 이점`은 무엇인가요?

> - `렌더링의 효율성`이라고 알고 있습니다. setState가 `동기`일 시에는 값이 여러번 바뀌는 경우, <br> 그 `바뀌는 수만큼 렌더링`을 새로 해줘야 하지만, <br> `비동기`일 경우 그 로직을 처리하는 동안, <br> 여러번 값이 바뀌어도 `나중에 한번만 렌더링`을 해준다는 이점이 있습니다.

### 4. 리액트의 `useCallback`, `useEffect`등을 사용할 때 `의존성 배열`을 받게 됩니다.<br> 이 배열의 `역할`은 무엇인가요?

> - 배열 내에 있는 `값이 변경`될 때 마다 메서드 마다 있는 `의존성 배열`의 값이 변경되었을 경우에 <br> 실행되는 `추가 함수 로직`이 실행됩니다.

### 5. `의존성 배열`은 `shallow equal`, `deep equal`중 무엇을 하게 되나요?

- `shallow equal`, 자식 컴포넌트의 `불필요한 렌더링`을 방지하기 위해, <br> `참조 동일성`에 의존하는 것에 `최적화` 되어 있음.

---

### 6. props로 `전달받은 함수`는, props나 상태가 업데이트될 때마다 새로 생성이 됩니다. <br> 이 때 `최적화할 수 있는 방법`은 어떤게 있나요?

- 아래 코드의 경우, useCallback을 사용을 하더라도 isClicked 의존성을 가지고 있습니다. 이 경우, 아예 의존성이 없게 만드는 방법이 있나요?

  ```js
  const handleToggle = useCallback(() => setIsClicked(!isClicked), [isClicked]);
  ```

- 다이나믹한 데이터를 받아올 때, useEffect에서 의존성배열을 어떻게 하실건가요?

- Next.js에서 getStaticProps, getServerSideProps의 차이점은?

- useLayoutEffect는 무엇인가요?

- 리액트를 사용할 때, 최적화에 신경쓰는 부분은 어떤 것이 있는지 구체적인 예시가 있나요?

- 아래와 같이 자식 컴포넌트를 React.memo로 감쌌을 때 props를 통해서 전달되어지는 함수에 useCallback을 사용한 경우와 사용하지 않은 경우에 차이가 있나요?

```js
  function Parent(){
  const handleClick = useCallback(() => { ... }, []); // (1)
  const handleClick = () =>{ ... } // (2)

      return <Child onClick={handleClick} />

  }


function Child({ onClick }) {
return <div onClick={onClick} />
}
export default React.memo(Child);
```

- React.memo의 특징에 대해서 설명해주세요.

- 얕은 비교(Shallow Equal)와 깊은 비교에 대해서 설명해주세요.

- React의 hook에 대해서 설명해주세요.

- 주로 어떤 경우에 custom hook을 사용했고, 그로 인해서 얻은 장점이 무엇인가요?

- Styled-components의 퍼포먼스에 대한 이슈에 대해서 경험해보신 적이 있나요?

- 리액트의 성능개선 방법에 대해서 설명해주세요.

- 상태 관리에 대해서 설명해주세요.

```

```
